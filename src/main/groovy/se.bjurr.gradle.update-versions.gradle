plugins {
	id "com.github.ben-manes.versions"
}

// ---- default config ----
interface UpdateVersionsPluginExtension {
	Property<String> getIgnoreDependenciesRegexp()
}

def extension = project.extensions.create("updateVersions", UpdateVersionsPluginExtension)
extension.ignoreDependenciesRegexp.convention("")
// ---- default config ----

def getUpdatableDependencies(dependencies,ignoreDependenciesRegexp) {
	dependencies
			.collect {
				[
					d: it,
					newVersion: it.available.release ?: (it.available.milestone ?: it.available.integration)
				]
			}
			.findAll {
				!"${it.d.group}:${it.d.name}:${it.d.version}"
						.matches(ignoreDependenciesRegexp.get())
			}
			.collect {
				[
					prettyPrint: "${it.d.group}:${it.d.name}:${it.d.version} -> ${it.newVersion}",
					newVersion: it.newVersion,
					compactFrom: "[\"']${it.d.group}:${it.d.name}:${it.d.version}[\"']",
					compactTo: "'${it.d.group}:${it.d.name}:${it.newVersion}'",
					verboseFrom: "group:\\s*[\"']${it.d.group}[\"'],\\s*name:\\s*[\"']${it.d.name}[\"'],\\s*version:\\s*[\"']${it.d.version}[\"']"
				]
			}
			.findAll {
				def buildGradleContent = getBuildGradleFile().text
				[
					it.compactFrom,
					it.verboseFrom
				].find {
					java.util.regex.Pattern.compile(it, java.util.regex.Pattern.DOTALL)
							.matcher(buildGradleContent)
							.find()
				}
			}
}

def isNonStable(v) {
	def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> v.candidate.version.toUpperCase().contains(it) }
	def stableVersion = v.candidate.version ==~ /^[0-9,.v-]+(-r)?$/
	return !stableKeyword && !stableVersion
}

def getBuildGradleFile() {
	new File("$rootDir/build.gradle")
}

task showUpdateableDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		def updatable = getUpdatableDependencies(result.outdated.dependencies,ignoreDependenciesRegexp)
		if (updatable.isEmpty()) {
			println """\

      All dependencies are up-to-date.
      """.stripIndent()
		} else {
			println "\nThere are dependencies that can be updated:\n"
			updatable.each { dependency->
				println "  ${dependency.prettyPrint}"
			}
			println """\

      Update dependencies with:

      ./gradlew updateDependencies
      """.stripIndent()
		}
	}
}

task updateDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		def updatable = getUpdatableDependencies(result.outdated.dependencies,ignoreDependenciesRegexp)
		if (!updatable.isEmpty()) {
			def buildGradleFile = getBuildGradleFile()
			def buildGradleContent = buildGradleFile.text
			println "\nStepping dependencies:\n"
			updatable.each { dependency->
				println "  ${dependency.prettyPrint}"
				[
					dependency.compactFrom,
					dependency.verboseFrom
				].each { from ->
					buildGradleContent = java.util.regex.Pattern.compile(from, java.util.regex.Pattern.DOTALL)
							.matcher(buildGradleContent)
							.replaceAll(dependency.compactTo)
				}
			}
			println "\nWriting ${buildGradleFile}"
			buildGradleFile.text = buildGradleContent
		}
	}
}

tasks.named("build") { finalizedBy("showUpdateableDependencies") }
