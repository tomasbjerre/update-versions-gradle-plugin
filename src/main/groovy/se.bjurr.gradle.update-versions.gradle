plugins {
	id "com.github.ben-manes.versions"
}

interface UpdateVersionsPluginExtension {
	Property<String> getIgnoreDependenciesRegexp()
}

def extension = project.extensions.create("updateVersions", UpdateVersionsPluginExtension)
extension.ignoreDependenciesRegexp.convention("")


def getGradleFiles() {
	def files = []
	if (buildscript?.sourceFile) {
		files << buildscript.sourceFile
	}
	return files
}

def isPluginMarker(dep) {
	dep.group && dep.name == "${dep.group}.gradle.plugin"
}

def getPluginId(dep) {
	return dep.group
}

def isNonStable(v) {
	def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> v.candidate.version.toUpperCase().contains(it) }
	def stableVersion = v.candidate.version ==~ /^[0-9,.v-]+(-r)?$/
	return !stableKeyword && !stableVersion
}

def getUpdatableDependencies(dependencies, ignoreDependenciesRegexp) {
	dependencies
			.collect { dep ->
				[
					d: dep,
					newVersion: dep.available.release ?: (dep.available.milestone ?: dep.available.integration)
				]
			}
			.findAll { info ->
				!"${info.d.group}:${info.d.name}:${info.d.version}".matches(ignoreDependenciesRegexp)
			}
			.collect { info ->
				if (isPluginMarker(info.d)) {
					def pluginId = getPluginId(info.d)
					return [
						prettyPrint   : "plugin ${pluginId}:${info.d.version} -> ${info.newVersion}",
						fullCoordinate: "${info.d.group}:${info.d.name}:${info.d.version}",
						newVersion    : info.newVersion,
						fromPatterns  : [
							// Groovy DSL
							"id\\s+['\"]${pluginId}['\"]\\s+version\\s+['\"]${info.d.version}['\"](\\s+apply\\s+false)?",
							// Kotlin DSL
							"id\\(\\s*['\"]${pluginId}['\"]\\s*\\)\\s+version\\s+['\"]${info.d.version}['\"](\\s+apply\\s+false)?"
						],
						toGroovy      : "id \"${pluginId}\" version \"${info.newVersion}\"",
						toKotlin      : "id(\"${pluginId}\") version \"${info.newVersion}\""
					]
				} else {
					return [
						prettyPrint   : "${info.d.group}:${info.d.name}:${info.d.version} -> ${info.newVersion}",
						fullCoordinate: "${info.d.group}:${info.d.name}:${info.d.version}",
						newVersion    : info.newVersion,
						fromPatterns: [
							// Flexible pattern for 'group:name:version' in single or double quotes
							"['\"]\\s*${info.d.group}:${info.d.name}:${info.d.version}\\s*['\"]",
							// Flexible pattern for map notation: group: '...', name: '...', version: '...'
							"group:\\s*['\"]${info.d.group}['\"],\\s*name:\\s*['\"]${info.d.name}['\"],\\s*version:\\s*['\"]${info.d.version}['\"]"
						],
						toGroovy      : "\"${info.d.group}:${info.d.name}:${info.newVersion}\"",
						toKotlin      : "\"${info.d.group}:${info.d.name}:${info.newVersion}\""
					]
				}
			}
			.findAll { info ->
				getGradleFiles().any { file ->
					info.fromPatterns.any { pattern ->
						def found = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL).matcher(file.text).find()
						logger.info("Checking if file ${file.name} content matches pattern ${pattern} found? ${found}")
						found
					}
				}
			}
}

def handleDependencies(result, ignoreDependenciesRegexp, boolean writeChanges) {
	def updatable = getUpdatableDependencies(result.outdated.dependencies, ignoreDependenciesRegexp)
	if (updatable.isEmpty()) {
		logger.lifecycle("""
        â˜€ï¸  All dependencies are up-to-date.
        """.stripIndent())
		return
	}

	if (writeChanges) {
		def allUpdatedDeps = []

		getGradleFiles().each { file ->
			def content = file.text
			def updatedDeps = []
			def isKotlin = file.name.endsWith(".kts")

			updatable.each { dep ->
				logger.info("Checking ${file.name} for updates to ${dep.prettyPrint}")
				dep.fromPatterns.each { patternStr ->
					logger.info("  Using pattern: ${patternStr}")
					def pattern = java.util.regex.Pattern.compile(patternStr, java.util.regex.Pattern.DOTALL)

					def matcher = pattern.matcher(content)
					def isPluginPattern = patternStr.contains("id\\s+") || patternStr.contains("id\\(")
					
					if (isPluginPattern) {
						// Plugin patterns need special handling for "apply false"
						while (matcher.find()) {
							logger.info("    Found match for pattern: ${patternStr}")
							def applyFalse = matcher.groupCount() >= 1 ? (matcher.group(1) ?: "") : ""
							def replacementBase = isKotlin ? dep.toKotlin.toString() : dep.toGroovy.toString()
							content = matcher.replaceFirst { _ -> replacementBase + applyFalse }
							
							updatedDeps << [
								file       : file.name,
								prettyPrint : dep.prettyPrint,
								newVersion : dep.newVersion
							]
							
							// Create new matcher with updated content
							matcher = pattern.matcher(content)
						}
					} else {
						// For dependencies, we can use replaceAll since there are no capture groups
						if (matcher.find()) {
							logger.info("    Found match for pattern: ${patternStr}")
							def replacement = (isKotlin ? dep.toKotlin : dep.toGroovy).toString()
							content = pattern.matcher(content).replaceAll(replacement)
							
							updatedDeps << [
								file       : file.name,
								prettyPrint : dep.prettyPrint,
								newVersion : dep.newVersion
							]
						}
					}
				}
			}

			if (!updatedDeps.isEmpty()) {
				file.text = content
				allUpdatedDeps.addAll(updatedDeps)
			}
		}

		if (!allUpdatedDeps.isEmpty()) {
			logger.lifecycle("""
			ðŸ“ Updated dependencies:

            """.stripIndent() + allUpdatedDeps.collect { upd -> "  ðŸ“¦ ${upd.prettyPrint}" }.unique().sort().join("\n") + "\n")
		}
	} else {
		logger.lifecycle("""
		ðŸ“ There are dependencies that can be updated:
        """.stripIndent())

		logger.lifecycle(updatable.collect { "  ðŸ“¦ " + it.prettyPrint }.unique().sort().join("\n"))

		logger.lifecycle("""
        
        ðŸ”„ Update dependencies with:
        
          ./gradlew updateDependencies
        
        """.stripIndent())
	}
}

task showUpdateableDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		handleDependencies(result, extension.ignoreDependenciesRegexp.get(), false)
	}
}

task updateDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		handleDependencies(result, extension.ignoreDependenciesRegexp.get(), true)
	}
}

boolean runningInCI() {
	def env = System.getenv()
	return (
			env['CI']?.toBoolean() ||
			env['GITHUB_ACTIONS']?.toBoolean() ||
			env['GITLAB_CI']?.toBoolean() ||
			env['TRAVIS']?.toBoolean() ||
			env['CIRCLECI']?.toBoolean() ||
			env['JENKINS_URL'] != null ||
			env['TF_BUILD']?.toBoolean() || // Azure Pipelines
			env['BUILDKITE']?.toBoolean()
			)
}

if (runningInCI()) {
	logger.lifecycle("Running in CI, saving time by not showing updatable dependencies after build.")
}else {
	tasks.named("build") { finalizedBy("showUpdateableDependencies") }
}
