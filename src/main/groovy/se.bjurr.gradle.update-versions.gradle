plugins {
	id "com.github.ben-manes.versions"
}

def getGivenConfigUpdateVersions() {
	def givenConfig = [
		// ---- start of default config ----
		// ignoreDependenciesRegexp: (jakarta\.inject|jakarta\.servlet).*
		ignoreDependenciesRegexp: project.getProperties().getOrDefault("ignoreDependenciesRegexp", ""),
		// ---- end of default config ----
	]
	return givenConfig
}

def getEffectiveConfigUpdateVersions() {
	return getGivenConfigUpdateVersions() + []
}

logger.info("Update Versions: Given config: ${getGivenConfigUpdateVersions()}")
logger.info("Update Versions: Effective config: ${getEffectiveConfigUpdateVersions()}")

def getUpdatableDependencies(dependencies) {
	dependencies
			.collect {
				[
					d: it,
					newVersion: it.available.release ?: (it.available.milestone ?: it.available.integration)
				]
			}
			.findAll {
				!"${it.d.group}:${it.d.name}:${it.d.version}"
						.matches(getEffectiveConfigUpdateVersions().ignoreDependenciesRegexp)
			}
			.collect {
				[
					prettyPrint: "${it.d.group}:${it.d.name}:${it.d.version} -> ${it.newVersion}",
					newVersion: it.newVersion,
					compactFrom: "[\"']${it.d.group}:${it.d.name}:${it.d.version}[\"']",
					compactTo: "'${it.d.group}:${it.d.name}:${it.newVersion}'",
					verboseFrom: "group:\\s*[\"']${it.d.group}[\"'],\\s*name:\\s*[\"']${it.d.name}[\"'],\\s*version:\\s*[\"']${it.d.version}[\"']"
				]
			}
			.findAll {
				def buildGradleContent = getBuildGradleContent()
				[
					it.compactFrom,
					it.verboseFrom
				].find {
					java.util.regex.Pattern.compile(it, java.util.regex.Pattern.DOTALL)
							.matcher(buildGradleContent)
							.find()
				}
			}
}

def isNonStable(v) {
	def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> v.candidate.version.toUpperCase().contains(it) }
	def stableVersion = v.candidate.version ==~ /^[0-9,.v-]+(-r)?$/
	return !stableKeyword && !stableVersion
}

def getBuildGradleContent() {
	def buildGradleFile = new File("$rootDir/build.gradle")
	return buildGradleFile.text
}

task showUpdateableDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		def updatable = getUpdatableDependencies(result.outdated.dependencies)
		if (updatable.isEmpty()) {
			println """\

      All dependencies are up-to-date.
      """.stripIndent()
		} else {
			println "\nThere are dependencies that can be updated:\n"
			updatable.each { dependency->
				println "  ${dependency.prettyPrint}"
			}
			println """\

      Update dependencies with:

      ./gradlew updateDependencies
      """.stripIndent()
		}
	}
}

task updateDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		def updatable = getUpdatableDependencies(result.outdated.dependencies)
		if (!updatable.isEmpty()) {
			def buildGradleContent = getBuildGradleContent()
			println "\nStepping dependencies:\n"
			updatable.each { dependency->
				println "  ${dependency.prettyPrint}"
				[
					dependency.compactFrom,
					dependency.verboseFrom
				].each { from ->
					buildGradleContent = java.util.regex.Pattern.compile(from, java.util.regex.Pattern.DOTALL)
							.matcher(buildGradleContent)
							.replaceAll(dependency.compactTo)
				}
			}
			println "\nWriting ${buildGradleFile}"
			buildGradleFile.text = buildGradleContent
		}
	}
}

tasks.named("build") { finalizedBy("showUpdateableDependencies") }
