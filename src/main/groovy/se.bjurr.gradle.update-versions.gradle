plugins {
	id "com.github.ben-manes.versions"
}

interface UpdateVersionsPluginExtension {
	Property<String> getIgnoreDependenciesRegexp()
}

def extension = project.extensions.create("updateVersions", UpdateVersionsPluginExtension)
extension.ignoreDependenciesRegexp.convention("")


def getGradleFiles() {
	def files = []
	if (buildscript?.sourceFile) {
		files << buildscript.sourceFile
	}
	return files
}

def isPluginMarker(dep) {
	dep.group && dep.name == "${dep.group}.gradle.plugin"
}

def getPluginId(dep) {
	return dep.group
}

def isNonStable(v) {
	def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> v.candidate.version.toUpperCase().contains(it) }
	def stableVersion = v.candidate.version ==~ /^[0-9,.v-]+(-r)?$/
	return !stableKeyword && !stableVersion
}


def getUpdatableDependencies(dependencies, ignoreDependenciesRegexp) {
	dependencies
			.collect { dep ->
				[
					d: dep,
					newVersion: dep.available.release ?: (dep.available.milestone ?: dep.available.integration)
				]
			}
			.findAll { info ->
				!"${info.d.group}:${info.d.name}:${info.d.version}".matches(ignoreDependenciesRegexp)
			}
			.collect { info ->
				if (isPluginMarker(info.d)) {
					def pluginId = getPluginId(info.d)
					return [
						prettyPrint   : "plugin ${pluginId}:${info.d.version} -> ${info.newVersion}",
						fullCoordinate: "${info.d.group}:${info.d.name}:${info.d.version}",
						newVersion    : info.newVersion,
						fromPatterns  : [
							// Groovy DSL
							"id\\s+['\"]${pluginId}['\"]\\s+version\\s+['\"]${info.d.version}['\"](\\s+apply\\s+false)?",
							// Kotlin DSL
							"id\\(\\s*['\"]${pluginId}['\"]\\s*\\)\\s+version\\s+['\"]${info.d.version}['\"](\\s+apply\\s+false)?"
						],
						toGroovy      : "id \"${pluginId}\" version \"${info.newVersion}\"",
						toKotlin      : "id(\"${pluginId}\") version \"${info.newVersion}\""
					]
				} else {
					return [
						prettyPrint   : "${info.d.group}:${info.d.name}:${info.d.version} -> ${info.newVersion}",
						fullCoordinate: "${info.d.group}:${info.d.name}:${info.d.version}",
						newVersion    : info.newVersion,
						fromPatterns: [
							// Flexible pattern for 'group:name:version' in single or double quotes
							"['\"]\\s*${info.d.group}:${info.d.name}:${info.d.version}\\s*['\"]",
							// Flexible pattern for map notation: group: '...', name: '...', version: '...'
							"group:\\s*['\"]${info.d.group}['\"],\\s*name:\\s*['\"]${info.d.name}['\"],\\s*version:\\s*['\"]${info.d.version}['\"]"
						],
						toGroovy      : "\"${info.d.group}:${info.d.name}:${info.newVersion}\"",
						toKotlin      : "\"${info.d.group}:${info.d.name}:${info.newVersion}\""
					]
				}
			}
			.findAll { info ->
				getGradleFiles().any { file ->
					info.fromPatterns.any { pattern ->
						def found = java.util.regex.Pattern.compile(pattern, java.util.regex.Pattern.DOTALL).matcher(file.text).find()
						logger.info("Checking if file ${file.name} content matches pattern ${pattern} found? ${found}")
						found
					}
				}
			}
}

def handleDependencies(result, ignoreDependenciesRegexp, boolean writeChanges) {
	def updatable = getUpdatableDependencies(result.outdated.dependencies, ignoreDependenciesRegexp)
	if (updatable.isEmpty()) {
		logger.lifecycle("""
            All dependencies are up-to-date.
        """.stripIndent())
		return
	}

	if (writeChanges) {
		def allUpdatedDeps = []

		getGradleFiles().each { file ->
			def content = file.text
			def updatedDeps = []
			def isKotlin = file.name.endsWith(".kts")

			updatable.each { dep ->
				dep.fromPatterns.each { patternStr ->
					// Ensure regex source is a plain Java String
					def regexSource = (patternStr instanceof java.util.regex.Pattern ? patternStr.pattern() : patternStr.toString()) as String
					def matcher = java.util.regex.Pattern.compile(regexSource, java.util.regex.Pattern.DOTALL).matcher(content)

					while (matcher.find()) {
						def isPluginPattern = regexSource.contains("id\\s+") || regexSource.contains("id\\(")
						if (isPluginPattern) {
							// Capture optional "apply false" if present
							def applyFalse = matcher.groupCount() >= 1 ? (matcher.group(1) ?: "") : ""
							def replacementBase = isKotlin ? dep.toKotlin.toString() : dep.toGroovy.toString()
							// Use plain String in the closure
							content = matcher.replaceFirst { _ -> replacementBase + applyFalse }
						} else {
							def replacement = (isKotlin ? dep.toKotlin : dep.toGroovy).toString()
							content = matcher.replaceFirst(replacement)
						}

						updatedDeps << [
							file       : file.name,
							prettyPrint : dep.prettyPrint,
							newVersion : dep.newVersion
						]
					}
				}
			}

			if (!updatedDeps.isEmpty()) {
				file.text = content
				allUpdatedDeps.addAll(updatedDeps)
			}
		}

		if (!allUpdatedDeps.isEmpty()) {
			logger.lifecycle("""
			Updated dependencies:

            """.stripIndent() + allUpdatedDeps.collect { upd -> "  ${upd.prettyPrint}" }.join("\n") + "\n")
		}
	} else {
		logger.lifecycle("""
		There are dependencies that can be updated:
        """.stripIndent())

		logger.lifecycle(updatable.collect { "  - " + it.prettyPrint }.join("\n"))

		logger.lifecycle("""
        
        Update dependencies with:
        
          ./gradlew updateDependencies
        
        """.stripIndent())
	}
}

task showUpdateableDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		handleDependencies(result, extension.ignoreDependenciesRegexp.get(), false)
	}
}

task updateDependencies(type: com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask) {
	checkForGradleUpdate = false
	dependencyUpdates.gradleReleaseChannel = "current"
	rejectVersionIf { isNonStable(it) }
	outputFormatter = { result ->
		handleDependencies(result, extension.ignoreDependenciesRegexp.get(), true)
	}
}

tasks.named("build") { finalizedBy("showUpdateableDependencies") }
